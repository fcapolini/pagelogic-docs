---
description: Isomorphic HTML-based reactive web framework
---

# PageLogic

## What it does

PageLogic brings reactive web development, as popularized by [React](https://react.dev/), [Vue](https://vuejs.org/), and [Angular](https://angular.io/), to HTML itself. It aims to remove the complexity and boilerplate of reactive frameworks, while retaining the advantages of reactivity and componentization.

It augments HTML with:

* [logic values](broken-reference), specified with `:`-prefixed attributes
* [reactive expressions](broken-reference), wrapped in `{...}` clauses
* [visibility scopes](broken-reference), associated to elements with logic values
* [directives](broken-reference), declared as `<:...>` tags and used to modularize code.

PageLogic includes a [Node.js](https://nodejs.org/) server and an [Express](https://expressjs.com/) middleware that handle these HTML extensions and deliver standard HTML plus accompanying code to implement page behavior. By default, logic starts running in the server — to deliver content-ready pages for search engines indexing — and continues in the client — to provide a modern user experience.

Alternatively, pages can be precompiled using PageLogic CLI and delivered as static HTML, or embedded in web-based apps, with no external dependencies.

## Quick start

```html
<!-- www/index.html -->
<html>
  <body>
    <button :count={0} :on-click={() => count++}>
      Clicks: {count}
    </button>
  </body>
</html>
```

```bash
npm install -g pagelogic
pagelogic serve ./www
# http://127.0.0.1:3000
```

{% embed url="https://pagelogic.dev/samples/quick-start" %}

> This is a complete working example: all the boilerplate required by traditional frameworks is removed, and only what's relevant for the actual page logic remains.

{% hint style="info" %}
This is a complete working example: all the boilerplate required by traditional frameworks is removed, and only what's relevant for the actual page logic remains.
{% endhint %}

### How it works

* Because it declares logic values, `<button>` has its own scope, which includes the property `count`.
* The `{count}` expression lives in the same scope, and references the property. Since it’s reactive, it’s automatically updated whenever it changes.
* This happens when users click the button, thanks to the `on-click` event listener.
* The page is served complete with its initial content "Clicks: 0": page logic [starts in the server and continues in the client](broken-reference) by default.

When served through a PageLogic server, pages are compiled on the fly. In development mode, pages are recompiled automatically and the browser is refreshed when they change.

## Why PageLogic

* **Zero boilerplate** — forget ceremonies like React's `useState()`, `render()` etc. PageLogic handles these details behind the scenes, keeping your code clean and expressive.
* **Zero dependencies** — compiled pages only need their namesake JavaScript file, implementing page logic, and the PageLogic runtime, both generated by the compiler or the server.
* **Super lightweight** — because runtime, compiler and server were designed together, it sports a tiny size of less than 3kB (minified, compressed) in the browser.
* **No Virtual DOM** — PageLogic uses direct DOM reflection, a much lighter and efficient solution.
* **Isomorphic by design** — with other frameworks, delivering content-ready pages for search engine indexing can be complex: PageLogic server does it by default.
* **Advanced routing** — the same set of pages can work as a classic website and as a modern [SPA](https://en.wikipedia.org/wiki/Single-page\_application) at the same time.
* **Simple components** — going from a simple block of code to a reusable component is trivial and promotes building your own reusable libraries.
* **Flexible deployment** — PageLogic pages can be served using its own [Node.js](https://nodejs.org/) server or its [Express](https://expressjs.com/) middleware in your own projects, or can be used as precompiled HTML.
